<#@ assembly name="System.Core"
#><#@ include file="$(SolutionDir)Main\src\Arithmetic\Operators.ttinclude"
#><#@ import namespace="System.Linq"
#><#@ import namespace="System.Text"
#><#@ import namespace="System.Collections.Generic"
#><#@ output extension=".generated.cs"
#>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

using BenchmarkDotNet.NUnit;

using NUnit.Framework;

using IntOp = CodeJam.Arithmetic.Operators<int>;
using NullableDoubleOp = CodeJam.Arithmetic.Operators<double?>;

using static CodeJam.AssemblyWideConfig;

namespace CodeJam.Arithmetic
{
	[TestFixture(Category = BenchmarkConstants.BenchmarkCategory + ": Operators (generated)")]
	[CompetitionMetadata("CodeJam.Arithmetic.NumOperatorsPerfTest.generated.xml")]
	[Explicit("Server run speed not stable")]
	public class NumOperatorsPerfTest
	{
<#foreach (var op in ops) {
	if (op.Unary) {#>
		[Test]
		public void Int<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

		public class Int<#=op.Name#>Case : IntOperatorsBenchmark
		{
			private readonly Func<int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[CompetitionBaseline]
			public int <#=op.Name#>Baseline()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = <#=op.Sign#>ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int <#=op.Name#>Operator()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = _int<#=op.Name#>(ValuesB[i]);
				return result;
			}
		}

<#	}#>
<#	else {#>
		[Test]
		public void Int<#=op.Name#>() => CompetitionBenchmarkRunner.Run<Int<#=op.Name#>Case>(RunConfig);

		public class Int<#=op.Name#>Case : IntOperatorsBenchmark
		{
			private readonly Func<int, int, int> _int<#=op.Name#> = IntOp.<#=op.Name#>;

			[CompetitionBaseline]
			public int <#=op.Name#>Baseline()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] <#=op.Sign#> ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public int <#=op.Name#>Operator()
			{
				var result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = _int<#=op.Name#>(ValuesA[i], ValuesB[i]);
				return result;
			}
		}

<#		if (!op.IntOnly) {#>
		[Test]
		public void NullableDouble<#=op.Name#>() => CompetitionBenchmarkRunner.Run<NullableDouble<#=op.Name#>Case>(RunConfig);

		public class NullableDouble<#=op.Name#>Case : NullableDoubleOperatorsBenchmark
		{
			private readonly Func<double?, double?, double?> _double<#=op.Name#> = NullableDoubleOp.<#=op.Name#>;

			[CompetitionBaseline]
			public double? <#=op.Name#>Baseline()
			{
				double? result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = ValuesA[i] <#=op.Sign#> ValuesB[i];
				return result;
			}

			[CompetitionBenchmark]
			public double? <#=op.Name#>Operator()
			{
				double? result = 0;
				for (var i = 0; i < ValuesA.Length; i++)
					result = _double<#=op.Name#>(ValuesA[i], ValuesB[i]);
				return result;
			}
		}

<#		}#>
<#	}#>
<#}#>
	}
}